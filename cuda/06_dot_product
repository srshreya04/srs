%%writefile dot_product_wtime.cu
#include <stdio.h>
#include <cuda_runtime.h>
#include <omp.h>  // for omp_get_wtime()

// CUDA Kernel for partial dot products (reduction)
__global__ void dotProductCUDA(const float *A, const float *B, float *partialSum, int N)
{
    __shared__ float cache[256];
    int tid = threadIdx.x + blockIdx.x * blockDim.x;
    int cacheIndex = threadIdx.x;

    float temp = 0.0f;
    while (tid < N) {
        temp += A[tid] * B[tid];
        tid += blockDim.x * gridDim.x;
    }

    cache[cacheIndex] = temp;
    __syncthreads();

    // Reduction within block
    int i = blockDim.x / 2;
    while (i != 0) {
        if (cacheIndex < i)
            cache[cacheIndex] += cache[cacheIndex + i];
        __syncthreads();
        i /= 2;
    }

    if (cacheIndex == 0)
        partialSum[blockIdx.x] = cache[0];
}

// CPU Implementation
float dotProductCPU(const float *A, const float *B, int N)
{
    float sum = 0.0f;
    for (int i = 0; i < N; i++)
        sum += A[i] * B[i];
    return sum;
}

void testDotProduct(int N)
{
    printf("\n---------------------------------------\n");
    printf("Vector Size: %d\n", N);

    // Allocate host memory
    float *h_A = new float[N];
    float *h_B = new float[N];

    for (int i = 0; i < N; i++) {
        h_A[i] = 1.0f;     // simple test data
        h_B[i] = 2.0f;
    }

    // -------- CPU Computation --------
    double startCPU = omp_get_wtime();
    float cpuResult = dotProductCPU(h_A, h_B, N);
    double endCPU = omp_get_wtime();
    double timeCPU = (endCPU - startCPU) * 1000.0;  // ms

    // -------- GPU Computation --------
    float *d_A, *d_B, *d_partialSum;
    int blockSize = 256;
    int numBlocks = 256;
    size_t bytes = N * sizeof(float);

    cudaMalloc((void**)&d_A, bytes);
    cudaMalloc((void**)&d_B, bytes);
    cudaMalloc((void**)&d_partialSum, numBlocks * sizeof(float));

    cudaMemcpy(d_A, h_A, bytes, cudaMemcpyHostToDevice);
    cudaMemcpy(d_B, h_B, bytes, cudaMemcpyHostToDevice);

    double startGPU = omp_get_wtime();
    dotProductCUDA<<<numBlocks, blockSize>>>(d_A, d_B, d_partialSum, N);
    cudaDeviceSynchronize();
    double endGPU = omp_get_wtime();
    double timeGPU = (endGPU - startGPU) * 1000.0;  // ms

    // Copy partial results and sum on CPU
    float *h_partialSum = new float[numBlocks];
    cudaMemcpy(h_partialSum, d_partialSum, numBlocks * sizeof(float), cudaMemcpyDeviceToHost);

    float gpuResult = 0.0f;
    for (int i = 0; i < numBlocks; i++)
        gpuResult += h_partialSum[i];

    // -------- Verify correctness --------
    bool correct = fabs(cpuResult - gpuResult) < 1e-3;

    // -------- Print Results --------
    printf("CPU Result: %.2f, Time: %.4f ms\n", cpuResult, timeCPU);
    printf("GPU Result: %.2f, Time: %.4f ms\n", gpuResult, timeGPU);
    printf("Speedup:    %.2fx\n", timeCPU / timeGPU);
    printf("Result:     %s\n", correct ? "Correct ✅" : "Incorrect ❌");

    // Free memory
    delete[] h_A;
    delete[] h_B;
    delete[] h_partialSum;
    cudaFree(d_A);
    cudaFree(d_B);
    cudaFree(d_partialSum);
}

int main()
{
    int Ns[] = {100000, 1000000, 10000000};
    int numTests = sizeof(Ns) / sizeof(Ns[0]);

    for (int i = 0; i < numTests; i++)
        testDotProduct(Ns[i]);

    return 0;
}

!nvcc -Xcompiler -fopenmp -arch=sm_75 dot_product_wtime.cu -o dot_wtime
!./dot_wtime
